概述
===

　　由于系统不是理想的，因此就存在着网络系统中必须考虑的两个问题————丢包和延时。为了能够实时地排序和输出，就必须引入超时机制来对这两个问题进行很好的处理。</br>
　　在真实系统中，`所有数据在获得token计算数值时的时间戳可以看做它真正的发送时间`，在发送端缓冲区等待和在网络中传输的时间则应该被看作是它的传输时间。那么设超时机制的时间阈值为Tmax，如果一条数据发出后，经过了Tmax的时间依旧没有被接收系统接收到，那么就可以认为这条数据已经丢了，即使之后再收到这条数据，也认为它是脏数据，不再使用。<br/><br/>
　　对本系统来说，有以下几种需要考虑的超时情况（以下称prepare数据为P数据，commit数据为C数据）：<br/>
　　　　1、prepare值更大的P数据已经接收到了，超过Tmax时间后再接收到的prepare值更小的P数据认为是脏数据（现实中它已经传输了Tmax+的时间）<br/>
　　　　2、commit值更大的C数据已经接收到了，超过Tmax时间后再接收到的commit值更小的C数据认为是脏数据（同理）<br/>
　　　　3、由于P数据先发送，如果对应的C数据已经接收到了，但过了Tmax时间，仍旧没有收到相应的P数据，认为P数据已经丢了。<br/>    
　　　　4、P数据已经接收到了，由于它对应的C数据设定为一定是在2*maxSleepInterval(millisecond)内发出，因此P数据收到后经过Tmax+2*maxSleepInterval(millisecond)依旧没有收到它对应的C数据，就认为其C数据已经丢了。<br/><br/>
　　
　　为了简化算法，直接将Tmax+2*maxSleepInterval(millisecond)设定为新的Tmax作为真正的时间阈值使用，超时情况简化为：<br/>
　　　　1、Pbig数据已经接收到了，超过Tmax时间后再接收到的Psmall数据认为是脏数据<br/>
　　　　2、Cbig数据已经接收到了，超过Tmax时间后再接收到的Csmall数据认为是脏数据<br/>
　　　　3、C数据收到了，超过Tmax时间后收到的对应P数据认为是脏数据<br/>
　　　　4、P数据已经接收到了，超过Tmax时间后再接收到的对应C数据认为是脏数据<br/><br/>
   
　　Tmax可以设置为大于2*maxSleepInterval(millisecond)的任意时间，设置的值越大，系统的弹性越好，但输出结果的时间会相应延长。设置的值越接近2*maxSleepInterval(millisecond)，系统的弹性越小，但输出结果的时间会更快。<br/>
　　本题将Tmax设置为4*maxSleepInterval(millisecond)。<br/>

  <br/><br/>
　　    
算法描述
======

对一组数据对来说
------------
   
　　对于一组prepare-commit数据对来说，只有以下四种情况：
    
    * P数据和C数据都正确地收到（均接收到且没有触发超时条件1，2，3，4）
    * P数据正确接收到了，C数据没有接收到或者成为脏数据（C数据丢包或触发条件2，4）
    * P数据没有接收到或者成为脏数据（丢包或触发条件1,3），C数据接正确的收到了（接收到且没有触发条件2，4）
    * P数据和C数据都丢了或成为脏数据

　　由于真实的情景下，很难理解一个接收系统没有在规定的时间内收到prepare数据，还能接受commit数据，因此当一组数据的P数据丢包或者视为脏数据时，其C数据也应该同样被丢弃。因此只有第一种情况的C数据应该被认为是可以进入排序的<br/><br/>
  

对一个信道来说
-------------
    
　　如果将接收的过程分隔为(0,Tmax],(Tmax,2Tmax],(3Tmax,4Tmax]......</br>
　　那么第一个时间间隔(0,Tmax]内的数据存在以下几种情况:
   
    * 互相配对的P数据和C数据=======》和别的P，C的时间间隔都在Tmax内，没有触发超时条件1，2
    * 没有配对的P数据===========》和别的P数据在Tmax内，但是对应C数据如果不在下个时间间隔内，那么C数据就算丢了
    * 没有配对的C数据===========》和别的C数据在Tmax内，但是对应P数据如果不在下个时间间隔内，那么P数据丢了，这个C数据也要丢弃

　　将配对成功的C数据放入一个slice中，命名为Cslice。将没有配对的P数据放入一个map中（key:prepare数值，value:P数据），命名为Pmap，没有配对的C数据放入一个map中（key：prepare数值，value:C数据），命名为Cmap。<br/>
　　统计所有的P数据的prepare最大值设为Pmax，所有的C数据的commit的最大值设为Cmax，可以确定所有比Pmax小的P数据一定在这个时间段被`发送`，同理所有比Cmax小的C数据也一定在这个时间段被`发送`<br/><br/>
　　那么在第二个时间间隔(Tmax,2Tmax]内接收到的数据：
   
    * 互相配对的P数据和C数据======》与第一个时间间隔内的P,C的时间间隔仍然有可能在Tmax内(也可能不在)，统一认为没有超时
    * 没有配对的P数据=========》可能和上个时间段的C配对，可能和下个时间段的C配对，否则C数据丢失
    * 没有配对的C数据=========》可能和上个时间段的P配对，可能和下个时间段的P配对，否则P数据丢失
   
　　对于互相配对的P-C数据来说，没有触发任何的超时条件，那么将commit值小于Cmax的C数据加入到Cslice中，这些C数据`一定是第一个时间段就被发送了的`，只是在这个时间段才接收。将commit值大于Cmax的C数据放入一个新的slice称之为Cslicenew，我们不确定它们是在第一个时间段`发送`还是第二个时间段`发送`的。<br/>
　　将本周期内没有配对的P数据和上个周期保存的Cmap中的C数据进行比较，找到配对的C，由于这些C是第一个时间段发送且接收到的，那么将他们放入Cslice中，没有找到配对的P，放入Pmapnew中，留待下个时间段找寻配对。此时，如果Cmap中还有C数据没有P数据与其配对，由于到下个周期一定出现P数据超时,因此这些C数据被迫丢弃<br/>
　　将本周期内没有配对的C数据和上个周期保存的Pmap中的P数据进行比较，找到配对的P，由于这些C不确定在哪个时间段发送的，因此通过和Cmax进行比较，小于Cmax放入Cslice，否则放入Cslicenew。没有找到配对的C数据，放入Cmapnew中，留待下个时间段找寻配对。此时，如果Pmap中还有P数据，同样由于其C数据肯定超时，因此也被迫丢弃</br>
　　经过这样三个操作后，我们得到的Cslice一定可以确认它们的发送时间是第一个时间段（由Cmax保证），Cslicenew则可能是第一个时间段也可能是第二个时间段，但它们一定比Cslice里的数据大。<br/>
　　由于第一个时间段内发送的C数据在第三个时间周期及以后即使被接收也要判定超时需要丢弃，因此之后产生的新的正确的C数据中不可能再有比Cslice中小的数据了（小于的话，一定超时），因此这样就可以将Cslice排序后输出，作为第一批已判定的最小数据组。然后再将Cslicenew替换为Cslice，Pmapnew替换为Pmap，Cmapnew替换为Cmap。同时将Cmax替换为Cmaxlast，Pmax替换为Pmaxlast，相似的记下本周期内所有P数据prepare的最大值为新的Pmax，所有C数据commit的最大值为新的Cmax。接着下一个周期走<br/>
   
   在第三个时间间隔（2Tmax,3Tmax]内接受到的数据：
   
    * 互相配对的P数据和C数据
    * 没有配对的P数据=========》可能和上个时间段的C配对，可能和下个时间段的C配对，否则C数据丢失
    * 没有配对的C数据=========》可能和上个时间段的P配对，可能和下个时间段的P配对，否则P数据丢失
    
　　遍历所有互相配对的P数据和C数据，如果P数据的prepare值小于Pmaxlast，说明这个P数据一定是第一个时间间隔发送的，那么触发了超时条件1，这一对P-C对都需要丢弃。如果C数据的commit值小于Cmaxlast，那么同理触发了条件2这一对P-C对也要丢弃。剩下的没有触发超时条件1，2的P-C对，由于在同一个时间间隔内收到，也不会触发超时条件3，4，因此都是正确的数据。那么将commit值小于Cmax的C数据加入到Cslice中，这些C数据一定是上一个时间段发送的（由于Cslice现在还可能包括第一个时间段，但是无法证明，也无法挑出，因此统一认为都是上个时间段的，对超时时间也不必坚持的过于严谨），只是在这个时间段才接收。将commit值大于Cmax的C数据放入一个新的slice称之为Cslicenew，我们不确定它们是在上一个时间段`发送`还是本时间段`发送`的。<br/>
　　遍历本周期内没有配对的P数据，先通过和Pmaxlast比较，去掉触发超时条件1的数据，然后再和上个周期保存的Cmap中的C数据进行比较，找到配对的C，由于这些C是上一个时间段接收到的（发送时间可能在允许的范围下更早），那么将他们放入Cslice中，没有找到配对的P，放入Pmapnew中，留待下个时间段找寻配对。此时，如果Cmap中还有C数据没有P数据与其配对，由于到下个周期一定出现P数据超时,因此这些C数据被迫丢弃<br/>
　　遍历本周期内没有配对的C数据，先通过和Cmaxlast比较，去掉触发超时条件2的数据，然后再和上个周期保存的Pmap中的P数据进行比较，找到配对的P，由于这些C不确定在哪个时间段发送的，因此通过和Cmax进行比较，小于Cmax放入Cslice，否则放入Cslicenew。没有找到配对的C数据，放入Cmapnew中，留待下个时间段找寻配对。此时，如果Pmap中还有P数据，同样由于其C数据肯定超时，因此也被迫丢弃</br>
　　经过这样三个操作后，我们得到的Cslice一定可以确认它们的发送时间是上一个时间段或者允许的上上个时间段（由Cmax和Cmaxlast，Pmaxlast保证），Cslicenew则可能是第一个时间段也可能是第二个时间段，但它们一定比Cslice里的数据大。<br/>
　　由于第一个时间段内发送的C数据在第三个时间周期及以后即使被接收也要判定超时需要丢弃，因此之后产生的新的正确的C数据中不可能再有比Cslice中小的数据了（小于的话，一定超时），因此这样就可以将Cslice排序后输出，作为第一批已判定的最小数据组。然后将Cslicenew替换为Cslice，Pmapnew替换为Pmap，Cmapnew替换为Cmap，接着下一个周期走<br/>
    
   
 对多个信道来说
-------------  
   
  由于很难确保多信道的接收时间间隔刚好卡在同一时间戳，因此最好还是利用多个有序数组合并的类似算法，将各个信道的mingroup进行合并而不是每次把多信道的数据取出进行一同比较
