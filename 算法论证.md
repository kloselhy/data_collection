概述
===

   由于系统不是理想的，也就是说存在着丢数据的可能。为了能够实时地排序和输出，就必须引入流量控制的机制。由于数据源在发送数据时，prepare数据与commit数据之间的最大时间差为2*maxSleepInterval(millisecond)，假设流量控制的时间阈值为Tmax，也即是说，当收到prepare数据后过了Tmax的时间仍旧没有收到它对应的commit数据，就认为该数据已经丢失了（即使过后能收到该数据，但由于超过了时间阈值，认为它是一条脏数据，仍然需要丢弃），从理想情况来说，Tmax=2*maxSleepInterval(millisecond)就可以了，当然也可以设置一些余地，将Tmax设置来大于2*maxSleepInterval(millisecond)。  
    

算法描述
======

对一组数据对来说
------------
   
   对于一组prepare-commit数据对来说，只有以下四种情况：（以下称prepare数据为P数据，commit数据为C数据）
    
    * P数据和C数据都正确地收到
    * P数据接收到了，C数据没有接收到（包括C数据超时成为脏数据）
    * P数据没有接收到，C数据接收到了（在实际的系统中，真的允许没有prepare只有commit吗？我认为这也是脏数据，不计入统计）
    * P数据和C数据都丢了


对一个信道来说
-------------
    
   如果将接收的过程分隔为(0,Tmax],(Tmax,2Tmax],(3Tmax,4Tmax]......那么P数据对应的C数据不是在本时间范围内，就是在下个时间范围内被接收，如果超过了下个时间范围，那么C数据必然超过了Tmax的接收阈值成为脏数据。</br>
   那么第一个时间间隔(0,Tmax]内的数据存在以下几种情况:
   
    * 互相配对的P数据和C数据
    * 没有配对的P数据===========》C数据如果不在下个时间间隔内，那么C数据就算丢了
    * 没有配对的C数据===========》由于没有上个时间间隔，因此这个C数据一定是P数据丢了的脏数据

   将配对成功的C数据放入一个slice中，命名为Cslice，将没有配对的P数据放入一个map中（golang没有set，为了方便，放入map，value随便设个什么都可以），命名为Pmap.</br>
   
   那么在下一个时间间隔(Tmax,2Tmax]内接收到的数据：
   
    * 互相配对的P数据和C数据=========》由于P数据发送的时间在这个时间间隔内，因此C数据获得token的时间也一定在这个时间间隔内，因此它们比Cslice中的C数据都要大
    * 没有配对的P数据=========》等待下个时间间隔去寻觅配对
    * 没有配对的C数据=========》在Pmap中寻觅它的配对，如果找不到，说明它是脏数据
   
   将配对成功的C数据放入一个slice中，命名为Cslicenew。现在可以明确的是Cslicenew中的C数据是一定比Cslice中的所有数据大的。但是没有配对且不是脏数据的C数据呢？</br>
   我们可以将它们一一遍历，如果它的commit数值比Cslicenew中的最小值要小，就将它放入Cslice中，如果它比Cslicenew中的最小值要大，就将它放入到Clicenew中。
   
