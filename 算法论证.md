概述
===

   由于系统不是理想的，也就是说存在着丢数据的可能。为了能够实时地排序和输出，就必须引入流量控制的机制。由于数据源在发送数据时，prepare数据与commit数据之间的最大时间差为2*maxSleepInterval(millisecond)，假设流量控制的时间阈值为Tmax，也即是说，当收到prepare数据后过了Tmax的时间仍旧没有收到它对应的commit数据，就认为该数据已经丢失了（即使过后能收到该数据，但由于超过了时间阈值，认为它是一条脏数据，仍然需要丢弃），从理想情况来说，Tmax=2*maxSleepInterval(millisecond)就可以了，当然也可以设置一些余地，将Tmax设置来大于2*maxSleepInterval(millisecond)。  
    

算法描述
======

对一组数据对来说
------------
   
   对于一组prepare-commit数据对来说，只有以下四种情况：（以下称prepare数据为P数据，commit数据为C数据）
    * P数据和C数据都正确地收到
    * P数据接收到了，C数据没有接收到（包括C数据超时成为脏数据）
    * P数据没有接收到，C数据接收到了（在实际的系统中，真的允许没有prepare只有commit吗？我认为这也是脏数据，不计入统计）
    * P数据和C数据都丢了


对一个信道来说
-------------
    
   如果将接收的过程分隔为(0,Tmax],(Tmax,2Tmax],(3Tmax,4Tmax]......那么P数据对应的C数据不是在本时间范围内，就是在下个时间范围内被接收，如果超过了下个时间范围，那么C数据必然超过了Tmax的接收阈值成为脏数据。</br>
   那么一个时间间隔(NTmax,(N+1)Tmax]内的数据存在以下几种情况:
   
    * 互相配对的P数据和C数据
    * 没有配对的P数据===========》C数据如果不在下个时间间隔内，那么C数据就算丢了
    * 没有配对的C数据===========》P数据如果不在上个时间间隔内，那么这个C数据一定是超过Tmax的脏数据或者P数据丢了的脏数据

   将配对成功的C数据，和在上个时间间隔找到了对应P数据的C数据放入一个切片中（没有找到的就丢弃了），命名为Cslice，将没有配对的P数据放入一个map中（golang没有set，为了方便，放入map，value随便设个什么都可以），命名为Pmap.</br>
   
   那么在下一个时间间隔((N+1)Tmax,(N+2)Tmax]内接收到的数据：
   
    * 互相配对的P数据和C数据=========》由于P数据发送的时间在这个时间间隔内，因此C数据获得token的时间也一定在这个时间间隔内，因此它比Cslice中的C数据都要大
    * 没有配对的P数据=========》等待下个时间间隔去寻觅配对
    * 没有配对的C数据=========》如果它不是脏数据（Pmap中有对应的P数据）那么它的大小和Cslice中的数据是不确定的
   
